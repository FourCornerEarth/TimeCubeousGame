<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*---------------------------------------------------//
//    The Definitive Dynamic Textbox Engine V5       //
//    by Caleb Padron (nacho_chicken)                //
//                                                   //
//                              V5.0, August 8, 2013 //
//             Do not use without proper permissions //
//---------------------------------------------------*/

current_text=-1; //set to negative one so we can check if the alarm "creation" has been called or not
alarm[1]=1; //stupid GM not having a way to set creation codes through other instances

//this stuff down here is so the game doesn't crash in the Begin Step event
key_left=vk_left; //for easy porting to other systems in GM:S
key_right=vk_right;
key_up=vk_up;
key_down=vk_down;
key_advance=vk_space;
keycheck_left=keyboard_check_pressed(key_left); //for easy porting to other systems in GM:S
keycheck_right=keyboard_check_pressed(key_right);
keycheck_up=keyboard_check_pressed(key_up);
keycheck_down=keyboard_check_pressed(key_down);
keycheck_advance=keyboard_check_pressed(key_advance);

textbox_surface=surface_create(room_width,room_width);

start_pointer=0; //this is the pointer for the text loader to know where to start; it's for after you've merged all the text files into one
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//cleans data
ds_queue_destroy(cmd_data_queue);
ds_queue_destroy(cmd_pos_queue);

//text box variable off
global.textbox_ON = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i, file, temp_fname, text_queue, temp_text, loop_end;

temp_fname="text_engine_test_final.txt"; //db
test_level=32; //db

//soon-to-be constants
CMD_TEXTSPEED="S"; //db
CMD_TEXTVOICE="V"; //db
CMD_TEXTPAUSE="P"; //db
CMD_TEXTVARIABLE="X"; //db
CMD_TEXTVARIABLESET="XS"; //db
CMD_TEXTEFFECT="F"; //db
CMD_TEXTCOLOR="C"; //db
CMD_TEXTNAME="N"; //db
CMD_TEXTQUESTION="Q"; //db
CMD_TEXTQUESTIONTEXT="QT"; //db
CMD_TEXTQUESTIONPOINTER="QP"; //db
CMD_CUTINCLEAR="IC"; //db
CMD_CUTINNEW="IN"; //db
CMD_CUTINOLD="IO"; //db
CMD_CUTINMOVE="IM"; //db
CMD_CUTINANIMATE="IA"; //db
CMD_CUTINANIMATESTOP="IS"; //db
CMD_CUTINSWAP="IW"; //db
CMD_END="E"; //db
CMD_TEXTSPEED_NORMAL="N"; //db
CMD_TEXTSPEED_SLOW="S"; //db
CMD_TEXTSPEED_SLOWER="R"; //db
CMD_TEXTEFFECT_SFX="0"; //db
CMD_TEXTEFFECT_SFX_SHOCK="0"; //db
CMD_TEXTVOICE_NULL="0"; //db
CMD_TEXTVOICE_LOW="L"; //db
CMD_TEXTVOICE_MED="M"; //db
CMD_TEXTVOICE_HIGH="H"; //db
CMD_TEXTVOICE_THOUGHT="T"; //db
CMD_TEXTCOLOR_CLEAR="C"; //db
CMD_TEXTCOLOR_BLACK=0; //db
CMD_TEXTCOLOR_RED=1; //db
CMD_TEXTCOLOR_GREEN=2; //db
CMD_TEXTCOLOR_BLUE=3; //db
CMD_TEXTCOLOR_GRAY=4; //db
CMD_TEXTNAME_NULL="0"; //db
CMD_TEXTQUESTION_YN="Y"; //db
CMD_CUTINCLEAR_ALL="A"; //db
CMD_CUTIN_UNFLIPPED=1; //db
CMD_CUTIN_FLIPPED=-1; //db

CUTIN_TEST_NORMAL=0; //db
CUTIN_TEST_ANGRY=1; //db

TEXT_FILE_EXTENSION=".txt";

//textbox data
textbox_maxlines=4;
textbox_maxcolors=4;
textbox_maxcutins=6;
textbox_maxoptions=6;

//initialize random variables
textbox_closing=0; //if this is set to one, the textbox begins closing
textbox_fade_perstep=.1; //how much the textbox fades per step

textbox_overall_alpha_max=.9;
textbox_overall_alpha=0; //for the textbox surface

textbox_x=0;
textbox_y=room_height-160;
textbox_sprite=spr_textbox;
textbox_alpha=1;
textbox_anim=0; //for animated textboxes
textbox_anim_index=0;
textbox_anim_speed=0;
textbox_anim_subimgs=0;

textbox_arrow_draw=0;
textbox_arrow_x = (textbox_x+800)-40;
textbox_arrow_y=textbox_y+125;
textbox_arrow_sprite=spr_textbox_arrow;
textbox_arrow_color=$000000; //black
textbox_arrow_alpha=1;
textbox_arrow_anim=1; //for animated arrows
textbox_arrow_anim_index=0;
textbox_arrow_anim_speed=.1;
textbox_arrow_anim_subimgs=4;

textbox_name_enabled=0; //disables the name box by default
textbox_name_text="";
textbox_name_x=0;
textbox_name_y=room_height-199;
textbox_name_sprite=spr_textbox_namebox;
textbox_name_alpha=1;
textbox_name_anim=0; //for animated name boxes
textbox_name_anim_index=0;
textbox_name_anim_speed=0;
textbox_name_anim_subimgs=0;

textbox_text_x=textbox_x+40;
textbox_text_y=textbox_y+75;
textbox_text_color=$000000; //black
textbox_text_alpha=1;
textbox_text_paused=0; //if this is set to 1, the textbox will wait until the variable is reset

draw_set_font(global.fnt_textbox); //for the next calculation to work correctly
textbox_font_height= string_height("#"); //so we don't have to run string_height every time we need to use it

textbox_name_text_x=textbox_name_x+20;
textbox_name_text_y=textbox_name_y+24;
textbox_name_text_color=$000000; //also black
textbox_name_text_alpha=1;

textbox_question_enabled=0;
textbox_question_text_x_offset=24; //how much the question text is offset from the left end of the textbox
textbox_question_text_y_offset=6; //how much the question text is offset from the normal newline y
textbox_question_text_x_separation=32; //how much space is between the two questions
textbox_question_text_x[0]=textbox_question_text_x_offset;
textbox_question_text_x[1]=0; //this is set when the command is called
textbox_question_text_y=textbox_text_y+(textbox_font_height*(textbox_maxlines-1)); //so that the question text displays on the last line of the textbox
textbox_question_text_color=$7f7f7f; //gray
textbox_question_text_alpha=1;
textbox_question_text[0]="Yes";
textbox_question_text[1]="No";
for (i=2; i&lt;textbox_maxoptions; i+=1) //the maximum amount of question options is 6
{
  textbox_question_text[i]="";
}
textbox_question_text_width=string_width(textbox_question_text[0]);

textbox_question_cursor_x_offset=4; //how far away the cursor is from the text
textbox_question_cursor_y_offset=3; //how far down the cursor is compared to the actual position of the text
for (i=0; i&lt;2; i+=1)
{
  textbox_question_cursor_x[i]=0;
}
textbox_question_cursor_y=0;
textbox_question_cursor_sprite=spr_textbox_questionbox_cursor;
textbox_question_cursor_sprite_xsize=8;
textbox_question_cursor_color=$000000; //black
textbox_question_cursor_alpha=1;
textbox_question_cursor_anim=1; //for animated cursors
textbox_question_cursor_anim_index=0;
textbox_question_cursor_anim_speed=0.067;
textbox_question_cursor_anim_subimgs=2;

textbox_vnquestion_enabled=0; //for visual-novel-styled question boxes
textbox_vnquestion_sprite=spr_textbox_questionbox;
textbox_vnquestion_x=view_wview[view_current]/2;
textbox_vnquestion_y=64;
textbox_vnquestion_y_offset=0; //this is relative to how many answers there are
textbox_vnquestion_height=12; //the height of each individual part of the question box
textbox_vnquestion_alpha=1;

textbox_vnquestion_text_x=textbox_vnquestion_x;
textbox_vnquestion_text_y=textbox_vnquestion_y+5;
textbox_vnquestion_text_color=$000000; //black
textbox_vnquestion_text_alpha=1;

textbox_vnquestion_cursor_x=textbox_vnquestion_x;
textbox_vnquestion_cursor_y_offset=1;
for (i=0; i&lt;textbox_maxoptions; i+=1)
{
  textbox_vnquestion_cursor_y[i]=textbox_vnquestion_text_y+textbox_vnquestion_cursor_y_offset+(i*12);
}
textbox_vnquestion_cursor_y_move=1; //for moving the cursor gradually when choosing a different selection
textbox_vnquestion_cursor_current_y=textbox_vnquestion_cursor_y[0];
textbox_vnquestion_cursor_sprite=spr_textbox_questionbox_cursor;
textbox_vnquestion_cursor_alpha=.5;
textbox_vnquestion_cursor_anim=0; //for animated cursors
textbox_vnquestion_cursor_anim_index=0;
textbox_vnquestion_cursor_anim_speed=0;
textbox_vnquestion_cursor_anim_subimgs=0;

textbox_cursor_option=0; //which option is highlighted
for (i=0; i&lt;textbox_maxoptions; i+=1)
{
  textbox_cursor_option_pointer[i]=0; //which text file to go to for each option
}

//cut-in data initialization
textbox_cutin_enabled=1; //for CPU saving
textbox_cutin_fade=1; //whether cut-ins fade in and out upon creation and destruction
textbox_cutin_fade_perstep=.1; //how much cutins fade in and out per step
for (i=0; i&lt;textbox_maxcutins; i+=1)
{
  textbox_cutin_draw[i]=0; //whether this cut-in is being drawn or not
  textbox_cutin_x[i]=0;
  textbox_cutin_sprite[i,0]=-1;
  textbox_cutin_flipped[i]=CMD_CUTIN_UNFLIPPED;
  if (textbox_cutin_fade)
  {
    textbox_cutin_alpha[i]=0; //if the cutins fade in and out, we need to start at zero
  }
  else
  {
    textbox_cutin_alpha[i]=1;
  }
  textbox_cutin_parts[i]=1; //how many parts the sprite is composed of (for RAM-saving animation of eyes, mouth, etc.)
}
textbox_cutin_y=room_height;

//sound effects init
textbox_sound_open=snd_textbox_open;
textbox_sound_move=snd_textbox_move;
textbox_sound_select=snd_textbox_select;
textbox_sound_close=snd_textbox_close;


//init variables
current_cutins=0; //the current amount of cut-ins used

textbox_loadbox(temp_fname,start_pointer);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//input states
keycheck_left=keyboard_check_pressed(key_left);
keycheck_right=keyboard_check_pressed(key_right);
keycheck_up=keyboard_check_pressed(key_up);
keycheck_down=keyboard_check_pressed(key_down);
keycheck_advance=keyboard_check_pressed(key_advance);

//this is all in here so it's done first
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i, i2, temp_current_chr_str, fade_waiting;

fade_waiting=0; //so that the typing and closing system will wait while the cut-ins are fading

//Cut-in Animation
if (current_cutins&gt;0)
{
  for (i=0; i&lt;current_cutins; i+=1) //repeats for every cut-in
  {
    if (textbox_closing)
    {
      if (textbox_cutin_alpha[i]&gt;0)
      {
        textbox_cutin_alpha[i]-=textbox_cutin_fade_perstep;
        fade_waiting+=1;
      }
    }
    else
    {
      if (textbox_cutin_fade)
      {
        if (textbox_cutin_draw[i])
        {
          if (textbox_cutin_alpha[i]&lt;1)
          {
            textbox_cutin_alpha[i]+=textbox_cutin_fade_perstep;
            fade_waiting+=1;
          }
        }
        else
        {
          if (textbox_cutin_alpha[i]&gt;0)
          {
            textbox_cutin_alpha[i]-=textbox_cutin_fade_perstep;
            if (textbox_cutin_alpha[i]==0)
            {
              current_cutins-=1;
            }
            else
            {
              fade_waiting+=1;
            }
          }
        } 
      }
      if (textbox_cutin_draw[i])
      {
        for (i2=0; i2&lt;textbox_cutin_parts[i]; i2+=1) //draws each part individually
        {
          if (textbox_cutin_anim[i,i2]) //checks if this part is to be animated, and if this cutin should be drawn
          {
            if (textbox_cutin_anim_index[i,i2]&lt;textbox_cutin_anim_subimgs[i,i2])
            {
             textbox_cutin_anim_index[i,i2]+=textbox_cutin_anim_speed[i,i2];
            } 
            else
            {
              if (textbox_cutin_anim_time_waited[i,i2]&lt;textbox_cutin_anim_wait[i,i2]) //checks to see if we need to wait a while before performing the animation again (i.e. blinking eyes)
              {
                textbox_cutin_anim_time_waited[i,i2]+=1;
              }
              else
              {
                textbox_cutin_anim_index[i,i2]=0;
                textbox_cutin_anim_time_waited[i,i2]=0;
                if (!textbox_cutin_anim_loop[i,i2]) //stops the animation if it's not supposed to loop
                {
                  textbox_cutin_anim[i,i2]=0;
                  if (textbox_text_paused) //unpauses the text after the animation
                  {
                    textbox_text_paused=0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

if (textbox_closing &amp;&amp; fade_waiting==0) //quit the textbox if everything is already faded out
{
  instance_destroy();
}

//typing functioning
if (!textbox_text_paused &amp;&amp; !textbox_closing &amp;&amp; fade_waiting==0 &amp;&amp; textbox_overall_alpha&gt;=textbox_overall_alpha_max) //if drawing the text is paused, we obviously don't want it to keep going
{
  if (current_chr&lt;string_length(edited_text[current_text]))
  {
    if (pause_time_to&gt;0) //for text pauses to function
    {
      if (pause_time_waited==pause_time_to) //increases the waiting time if it has not yet reached the goal
      {
        pause_time_waited=0; //inits the pause timers
        pause_time_to=0;
      }
      else
      {
        pause_time_waited+=1; //raise the timer so it can stop
      }
    }
    else
    {
      if (waiting_time mod text_draw_speed==0) //only progresses the text according to the text speed
      {
        if (current_chr==next_cmd_pos &amp;&amp; ds_queue_size(cmd_pos_queue)&gt;0)
        {
          ds_queue_dequeue(cmd_pos_queue);
          textbox_cmd_execute(ds_queue_dequeue(cmd_data_queue));
          next_cmd_pos=ds_queue_head(cmd_pos_queue);
        }
        else
        {
          current_chr+=1; //advance the text by one character for the typewriter effect
          output_text=string_copy(edited_text[current_text],1,current_chr); //sets the final text to be outputted
          temp_current_chr_str=string_char_at(output_text,current_chr); //to save CPU calling the check a few times
          line_chr[current_line]+=1; //for any equations involving how many characters are in a specific line
          line_text[current_line]+=temp_current_chr_str;//string_char_at(output_text,current_chr);
          if (temp_current_chr_str=="#") //checks for a newline, and changes current_line thusly
          {
            current_line+=1;
          }
          if (drawing_color==1)
          {
            current_color_chr_end[current_colors-1]+=1;
            color_text[current_colors-1]=string_copy(output_text,current_color_chr_start[current_colors-1],current_color_chr_end[current_colors-1]);
          }
          waiting_time=1; //resets time for waiting
          textbox_voice_play(text_voice,text_draw_speed);
        }
      }
      else
      {
        waiting_time+=1; //for the previous modulo calculation and modifying text speed
      }
    }
    //this next block of code executes any commands that may lie after the main text
    while (current_chr==string_length(edited_text[current_text]) &amp;&amp; ds_queue_size(cmd_pos_queue)&gt;0)
    {
      ds_queue_dequeue(cmd_pos_queue);
      textbox_cmd_execute(ds_queue_dequeue(cmd_data_queue));
      next_cmd_pos=ds_queue_head(cmd_pos_queue);
    }
  }
  else //if the text is finished drawing, we still want to do a couple of things
  {
    if (textbox_arrow_draw==0 &amp;&amp; (textbox_question_enabled==0 &amp;&amp; textbox_vnquestion_enabled==0))
    {
      textbox_arrow_draw=1; //sets the arrow so that it will be drawn, but not when there's a question
    }
  }
}

//Textbox Fade-in
if (textbox_overall_alpha&lt;textbox_overall_alpha_max)
{
  textbox_overall_alpha+=textbox_fade_perstep;
}

//Misc. Sprite Animation and Cursor Movement
if (textbox_arrow_draw==1 &amp;&amp; textbox_arrow_anim==1) //animates the textbox arrow if it can animate
{
  if (textbox_arrow_anim_index&lt;textbox_arrow_anim_subimgs)
  {
    textbox_arrow_anim_index+=textbox_arrow_anim_speed;
  }
  else
  {
    textbox_arrow_anim_index=0;
  }
}
if (textbox_question_enabled) //animates the question box cursor if it can animate
{
  if (keycheck_left ^^ keycheck_right) //exclusive-or; learn it or fail
  {
    audio_play_sound(textbox_sound_move,0,1);
    switch (textbox_cursor_option) //a bit of cheating here because pushing left or right would do the same thing in this situation
    {
      case 0: textbox_cursor_option=1; break;
      case 1: textbox_cursor_option=0; break;
      default: /*seriously, if you even manage to get the code here, you're doing something wrong.*/ break;
    }
  }
  if (textbox_question_cursor_anim==1)
  {
    if (textbox_question_cursor_anim_index&lt;textbox_question_cursor_anim_subimgs)
    {
      textbox_question_cursor_anim_index+=textbox_question_cursor_anim_speed;
    }
    else
    {
      textbox_question_cursor_anim_index=0;
    }
  }
}
if (textbox_vnquestion_enabled)
{
  if (keycheck_up &amp;&amp; !keycheck_down)
  {
    audio_play_sound(textbox_sound_move,1,0);
    if (textbox_cursor_option&gt;0)
    {
      textbox_cursor_option-=1;
    }
    else
    {
      textbox_cursor_option=question_amount-1;
    }
  }
  if (keycheck_down &amp;&amp; !keycheck_up)
  {
    audio_play_sound(textbox_sound_move,1,0);
    if (textbox_cursor_option&lt;question_amount-1)
    {
      textbox_cursor_option+=1;
    }
    else
    {
      textbox_cursor_option=0;
    }
  }
  if (textbox_vnquestion_cursor_y_move==1) //for moving the textbox gradually
  {
    if (textbox_vnquestion_cursor_current_y&lt;textbox_vnquestion_cursor_y[textbox_cursor_option])
    {
      if (textbox_vnquestion_cursor_current_y&lt;textbox_vnquestion_cursor_y[textbox_cursor_option]-4) //we want the cursor to move at different speeds depending on how much it has to travel
      {
        textbox_vnquestion_cursor_current_y+=4;
      }
      else if (textbox_vnquestion_cursor_current_y&lt;textbox_vnquestion_cursor_y[textbox_cursor_option])
      {
        textbox_vnquestion_cursor_current_y+=1;
      }
    }
    else if (textbox_vnquestion_cursor_current_y&gt;textbox_vnquestion_cursor_y[textbox_cursor_option])
    {
      if (textbox_vnquestion_cursor_current_y&gt;textbox_vnquestion_cursor_y[textbox_cursor_option]+4)
      {
        textbox_vnquestion_cursor_current_y-=4;
      }
      else if (textbox_vnquestion_cursor_current_y&gt;textbox_vnquestion_cursor_y[textbox_cursor_option])
      {
        textbox_vnquestion_cursor_current_y-=1;
      }
    }
  }
  else
  {
    textbox_vnquestion_cursor_current_y=textbox_vnquestion_cursor_y[textbox_cursor_option];
  }
}



/* DRAWING TO THE SURFACE
----
----
----*/
if (!surface_exists(textbox_surface)) //for solving annoying glitches
{
  textbox_surface=surface_create(room_width,room_width);
}
surface_set_target(textbox_surface);
  draw_clear_alpha($ffffff,0);
  draw_sprite_ext(textbox_sprite,textbox_anim_index,textbox_x,textbox_y,1,1,0,$ffffff,textbox_alpha);
  draw_set_font(global.fnt_textbox);
  if (textbox_name_enabled)
  {
    draw_set_color(textbox_name_text_color)
    draw_sprite(textbox_name_sprite,textbox_name_anim_index,textbox_name_x,textbox_name_y);
    draw_text(textbox_name_text_x,textbox_name_text_y,textbox_name_text);
  }
  draw_set_color(textbox_text_color);
  draw_text(textbox_text_x,textbox_text_y,output_text);
  for (i=0; i&lt;current_colors; i+=1)
  {
    draw_set_color(color_id[i]);
    draw_text(color_x[i],color_y[i],color_text[i]);
  }
  if (textbox_arrow_draw==1)
  {
    draw_sprite_ext(textbox_arrow_sprite,textbox_arrow_anim_index,textbox_arrow_x,textbox_arrow_y,1,1,0,textbox_arrow_color,textbox_arrow_alpha);
  }
  
  //in-box questions
  if (textbox_question_enabled)
  {
    draw_set_color(textbox_question_text_color);
    for (i=0; i&lt;2; i+=1)
    {
      draw_text(textbox_question_text_x[i],textbox_question_text_y,textbox_question_text[i]);
    }
    draw_sprite_ext(spr_textbox_cursor,textbox_question_cursor_anim_index,textbox_question_cursor_x[textbox_cursor_option],textbox_question_cursor_y,1,1,0,textbox_question_cursor_color,textbox_question_cursor_alpha);
  }

  //question boxes
  if (textbox_vnquestion_enabled)
  {
    draw_set_color(textbox_vnquestion_text_color);
    draw_sprite_ext(textbox_vnquestion_sprite,0,textbox_vnquestion_x,textbox_vnquestion_y+textbox_vnquestion_y_offset,1,1,0,$ffffff,textbox_vnquestion_alpha);
    for (i=0; i&lt;question_amount-1; i+=1)
    {
      draw_sprite_ext(textbox_vnquestion_sprite,1,textbox_vnquestion_x,textbox_vnquestion_y+textbox_vnquestion_y_offset+((i+1)*textbox_vnquestion_height),1,1,0,$ffffff,textbox_vnquestion_alpha);
    }
    draw_sprite_ext(textbox_vnquestion_sprite,2,textbox_vnquestion_x,textbox_vnquestion_y+textbox_vnquestion_y_offset+(question_amount*textbox_vnquestion_height),1,1,0,$ffffff,textbox_vnquestion_alpha);
    draw_set_halign(fa_middle);
    for (i=0; i&lt;question_amount; i+=1)
    {
      draw_text(textbox_vnquestion_text_x,textbox_vnquestion_text_y+textbox_vnquestion_y_offset+(i*textbox_vnquestion_height),textbox_question_text[i]);
    }
    draw_set_halign(fa_left);
  }
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i, i2;

//turn global textbox variable on
global.textbox_ON = true;

if (current_text&gt;-1) //checks if the alarm "create event" has been completed
{
  //drawing cut-ins first so that the textbox can cover them
  if (current_cutins&gt;0)
  {
    for (i=0; i&lt;current_cutins; i+=1) //repeats for every cut-in
    {
      for (i2=0; i2&lt;textbox_cutin_parts[i]; i2+=1) //draws each part individually
      {
        draw_sprite_ext(textbox_cutin_sprite[i,i2],textbox_cutin_anim_index[i,i2],textbox_cutin_x[i]+(textbox_cutin_part_x_offset[i,i2]*textbox_cutin_flipped[i]),textbox_cutin_y+textbox_cutin_part_y_offset[i,i2],textbox_cutin_flipped[i],1,0,$ffffff,textbox_cutin_alpha[i]);
      }
    }
  }
  if (!textbox_closing)
  {
    draw_surface_ext(textbox_surface,0,0,1,1,0,$ffffff,textbox_overall_alpha);
    if (textbox_vnquestion_enabled)
    {
      draw_sprite_ext(textbox_vnquestion_cursor_sprite,textbox_vnquestion_cursor_anim_index,textbox_vnquestion_cursor_x,textbox_vnquestion_cursor_current_y+textbox_vnquestion_y_offset,1,1,0,$ffffff,textbox_vnquestion_cursor_alpha);
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i;

if (current_chr&gt;=string_length(edited_text[current_text]))
{
  if (current_text&lt;total_boxes)
  {
    if (textbox_arrow_draw) //putting this here stops a bug where pushing space before the arrow is drawn closes the textbox altogether
    {
      output_text=""; //resets for prevention of bugs
      current_chr=0;
      current_colors=0;
      for (i=0; i&lt;textbox_maxcolors; i+=1)
      {
        current_color_chr_start[i]=0;
        current_color_chr_end[i]=0;
        color_id[i]=0;
        color_text[i]="";
      }
      textbox_arrow_draw=0;
      textbox_arrow_anim_index=0;
      current_text+=1;
      current_line=0;
      for (i=0; i&lt;textbox_maxlines; i+=1)
      {
        line_text[i]="";
        line_chr[i]=0;
      }
      textbox_cmd_load(input_text[current_text]);
      next_cmd_pos=ds_queue_head(cmd_pos_queue);
    }
  }
  else
  {
    if (textbox_question_enabled || textbox_vnquestion_enabled)
    {
      audio_play_sound(textbox_sound_select,1,0);
      textbox_question_pointer(textbox_cursor_option_pointer[textbox_cursor_option]);
      textbox_question_enabled=0;
      textbox_vnquestion_enabled=0;
    }
    else
    {
      if (!textbox_closing)
      {
        audio_play_sound(textbox_sound_close,1,0);
        textbox_closing=1;
      }
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
