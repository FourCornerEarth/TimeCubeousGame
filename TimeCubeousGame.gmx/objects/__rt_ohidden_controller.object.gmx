<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init Variables
/*
    Implied variables:
    
    _timeStart       = The time (in ms) that the timer was started
    _sequence       = The sequence currently being used
    _currentTimer   = The timer currently being scanned for (by index)
    _endTimer       = The timer value to call it quits at
 */
_timeLast = current_time;
__rt_g_timeDeltaAvg = 0;
__rt_g_timeDeltaSample = 0;
__rt_g_timeDeltaTotal = 0;
_paused = false;
ds_queue_clear(__rt_g_rankQueue); // Wipe all old ranks
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Background

// Destroy if the time is up
if (_currentTimer &gt;= _endTimer)
    instance_destroy();
    
// Calculate if paused:
if (_paused)
    _timeStart += current_time - _timeLast;
    
// Calculate average delta:
__rt_g_timeDeltaTotal += current_time - _timeLast;
_timeLast = current_time;
++ __rt_g_timeDeltaSample;
if (__rt_g_timeDeltaSample &gt;= TIME.dSamples &amp;&amp; ! _paused)
{
    __rt_g_timeDeltaAvg = __rt_g_timeDeltaTotal / TIME.dSamples;
    __rt_g_timeDeltaSample = 0;
    __rt_g_timeDeltaTotal = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check Triggers

if (_paused)
    exit;

// Grab the correct timer:
var __timer = _sequence[| _currentTimer];
var __stepTime = (current_time - _timeStart);

// Check if the target was missed:
if (__stepTime &gt; __timer[TIMER.time] + __rt_g_missTime + __rt_g_timeDeltaAvg)
{
    ++_currentTimer;
    if (__rt_g_functionTrigger != noone)
        script_execute(__rt_g_functionTrigger, rt_miss, _sequence, 
                       __timer[TIMER.trigger], 
                       __timer[TIMER.time])
    ds_queue_enqueue(__rt_g_rankQueue, rt_miss);
    
    exit;
}

// Grab the trigger to check:
var __trigger = __timer[TIMER.trigger];

// Check if pressed:
if (__rt_fhidden_check_trigger(__trigger))
{
    // Check if pressed WAY too early:
    if (__stepTime &lt; __timer[TIMER.time] - __rt_g_missTime - __rt_g_timeDeltaAvg)
    {
        // If the system is set to strict, we mark it as a miss:
        if (rt_system_getstrict())
        {
            ++_currentTimer;
            if (__rt_g_functionTrigger != noone)
                script_execute(__rt_g_functionTrigger, rt_miss, _sequence,
                               __timer[TIMER.trigger], 
                               __timer[TIMER.time]);
            ds_queue_enqueue(__rt_g_rankQueue, rt_miss);
        }
        
        // Otherwise we just ignore it:
        exit;
    }
    
    // If not too early, we check for the appropriate rank:
    var __match = -1, // No match by default
        __currentms = -1, // Current time for the acceptied rank
        __triggerDif = abs(__timer[TIMER.time] - __stepTime); // Current marked difference between exact time and pressed time
    for (var i = 0; i &lt; ds_list_size(__rt_g_rankList); ++i)
    {
        var __time = __rt_g_rankList[| i];
        
        if (__triggerDif &lt; __time)
        {
            
            if (__currentms == -1 || __currentms &gt; __time)
            {
                __match = i;
                __currentms = __time;
                continue;
            }
        }
        else
        {
            // If the player missed thanks to lag but would have fallen in time, we give it to them anyway:
            if (clamp(__triggerDif - __rt_g_timeDeltaAvg, 0, __triggerDif) &lt; __time)
            {
                if (__currentms == -1 || __currentms &gt; __time)
                {
                    __match = i;
                    __currentms = __time;
                    continue;
                }
            }
        }
    }
    
    // Record the rank scored:
    if (__rt_g_functionTrigger != noone)
        script_execute(__rt_g_functionTrigger, __match, _sequence,
                       __timer[TIMER.trigger], 
                       __timer[TIMER.time])
    ds_queue_enqueue(__rt_g_rankQueue, __match);
    ++_currentTimer;
}
else
{
    // We check if OTHER triggers were accidentally pressed!
    for (var i = 0; i &lt; ds_list_size(__rt_g_triggerList); ++i)
    {
        var __trig = __rt_g_triggerList[| i];
        // Check if pressed WAY too early:
        if (__rt_fhidden_check_trigger(__trig[TRIGGER.id]))
        {
            // Check if pressed WAY too early:
            if (__stepTime &lt; __timer[TIMER.time] - __rt_g_missTime - __rt_g_timeDeltaAvg)
            {
                // If the system is set to strict, we mark it as a miss:
                if (rt_system_getstrict())
                {
                    ++_currentTimer;
                    if (__rt_g_functionTrigger != noone)
                        script_execute(__rt_g_functionTrigger, rt_miss, _sequence,
                                       __timer[TIMER.trigger], 
                                       __timer[TIMER.time]);
                    ds_queue_enqueue(__rt_g_rankQueue, rt_miss);
                }
                
                // Otherwise we just ignore it:
                exit;
            }
            
            // If NOT pressed too early, it was the wrong note, so we miss:
            ++_currentTimer;
            if (__rt_g_functionTrigger != noone)
                script_execute(__rt_g_functionTrigger, rt_miss, _sequence,
                               __timer[TIMER.trigger], 
                               __timer[TIMER.time]);
            ds_queue_enqueue(__rt_g_rankQueue, rt_miss);
            exit;
        }
        
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
