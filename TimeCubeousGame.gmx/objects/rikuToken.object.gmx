<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_crosshair</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handles the player's side of this battle.
global.combo = 0;
global.maxCombo = 0;

q = undefined;
dir = 0;
state = 0;

tx = x;
ty = y;
i = 0;
p = 0;
// Initialize player's stats.
global.miss = 0;

queuedMoves = 0; // increments the amt of moves queued.
moveQ = ds_queue_create();
moved = 0;

// Initialize important variables for movement.
cursorRow = 4;
cursorCol = 4;
lastCRow = cursorRow;
lastCCol = cursorCol;

// The default keys for movement.
MENU_KEY_LEFT_1 = vk_left;
MENU_KEY_LEFT_2 = ord("A");
MENU_KEY_RIGHT_1 = vk_right;
MENU_KEY_RIGHT_2 = ord("D");
MENU_KEY_UP_1 = vk_up;
MENU_KEY_UP_2 = ord("W");
MENU_KEY_DOWN_1 = vk_down;
MENU_KEY_DOWN_2 = ord("S");

//smacking that glitch
hitting = false;

// checks if the character is in motion, where they are going and the index
//is there mostly for checking how many steps have been taken to regulate
//how much the sprite will travel
ismoving = 0;
movement = "down";
theindex = 0;
limitreached = 0;

//for when collisions happen
ishit = false;
//for brain collision
ishit2 = 0;

atkStr = global.atk;

// Set image speed to 0 to start. Used for animation speed.
image_speed = 0.25;

//collision with bullets
bucol = 0;

//sets shield cooldown
s_cooldown = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control movement within the grid.

if (global.playerTurnState[PLAYER_TURN_STATE.IMPORT] &amp;&amp; battle_playerTurn.turnRunning) {
    // Store the last position of the cursors.
    lastCRow = cursorRow;
    lastCCol = cursorCol;
                
          if (keyboard_check_pressed(global.MENU_KEY_LEFT_1) || keyboard_check_pressed(global.MENU_KEY_LEFT_2)){
            cursorCol--;
            } else if (keyboard_check_pressed(global.MENU_KEY_RIGHT_1) || keyboard_check_pressed(global.MENU_KEY_RIGHT_2)){
                cursorCol++;
            } else if (keyboard_check_pressed(global.MENU_KEY_UP_1) || keyboard_check_pressed(global.MENU_KEY_UP_2)){
                cursorRow--;
            } else if (keyboard_check_pressed(global.MENU_KEY_DOWN_1) || keyboard_check_pressed(global.MENU_KEY_DOWN_2)){
                cursorRow++;
            }
          
          // If the cursor is trying to go lower than the 0 slot, keep on 0 slot.
          if (cursorCol &lt; 0) {cursorCol = 0;}
          
          // If it's trying to go higher than the last slot, keep on last slot.
          else if (cursorCol &gt; 9) {cursorCol = 9;}
          
          // If the cursor is trying to go lower than the 0 slot, keep on 0 slot.
          if (cursorRow &lt; 0) {cursorRow = 0;}
          
          // If it's trying to go higher than the last slot, keep on last slot.
          else if (cursorRow &gt; 9) {cursorRow = 9;}
      //}
    
    //217 x
    //125 y
    /*ds_queue_enqueue(moveQ, 217 + (cursorCol*38));
    ds_queue_enqueue(moveQ, 125 + (cursorRow*38));*/
   x = 217 + (cursorCol*38);
   y = 125 + (cursorRow*38);
       
          
    global.moveOK = 0;
}

//defense mode code
else if (global.enmyTurnState[ENEMY_TURN_STATE.ATK] &amp;&amp; battle_enemyTurn.turnRunning) {
    // collision with bullet:
    if (bucol) {
        //if collided with bullet
        ishit = 1;
        bucol = 0;
    }
    // collision with brain: 
    brcol = collision_circle(x, y, sprite_height-30, obj_Core, true, true);
    //for test sake
    //brcol = 0;
    //if collided with brain
    if (brcol)
    {
        ishit2 = 1;
    }

    // Store the last position of the cursors.
    lastCRow = cursorRow;
    lastCCol = cursorCol;
    
    //riku can only move when moving is ok, 
    //when the token is not in motion and
    //when he is not in his hit animation
    if(/*!ds_queue_empty(global.move) &amp;&amp;*/ !ismoving &amp;&amp; !ishit2 &amp;&amp; !ishit) {
        /*
        // Then increment the cursor by how much we've moved.
        cursorRow += ds_queue_dequeue(global.move);
        // Then increment the cursor by how much we've moved.
        cursorCol += ds_queue_dequeue(global.move);*/
        
        if (keyboard_check_pressed(global.MENU_KEY_LEFT_1) || keyboard_check_pressed(global.MENU_KEY_LEFT_2)){
            cursorCol--;
        } else if (keyboard_check_pressed(global.MENU_KEY_RIGHT_1) || keyboard_check_pressed(global.MENU_KEY_RIGHT_2)){
            cursorCol++;
        } else if (keyboard_check_pressed(global.MENU_KEY_UP_1) || keyboard_check_pressed(global.MENU_KEY_UP_2)){
            cursorRow--;
        } else if (keyboard_check_pressed(global.MENU_KEY_DOWN_1) || keyboard_check_pressed(global.MENU_KEY_DOWN_2)){
            cursorRow++;
        }
                
        limitreached = 0;
        
        // If the cursor is trying to go lower than the 0 slot, keep on 0 slot.
        if (cursorCol &lt; 0) {cursorCol = 0; limitreached = 1;}
        
        // If it's trying to go higher than the last slot, keep on last slot.
        else if (cursorCol &gt; 8) {cursorCol = 8; limitreached = 1;}
        
        // If the cursor is trying to go lower than the 0 slot, keep on 0 slot.
        if (cursorRow &lt; 0) {cursorRow = 0; limitreached = 1;}
        
        // If it's trying to go higher than the last slot, keep on last slot.
        else if (cursorRow &gt; 3) {cursorRow = 3; limitreached = 1;}
        
        //now to check the actual direction the character is traveling in
        //first we make sure we didnt hit a border
        if (!limitreached)
        {
            // Move right
            if(cursorCol &gt; lastCCol) {
                ismoving = 1;
                movement = "right";   
            }
            // Move left
            if(cursorCol &lt; lastCCol) {
               ismoving = 1;
               movement = "left"; 
            }
            // Move up
            if(cursorRow &lt; lastCRow) {
                ismoving = 1;
                movement = "up";
            }
            // Move down
            if(cursorRow &gt; lastCRow) {
                ismoving = 1;
                movement = "down";
            }
        }
    }
    
    if (ismoving){
        switch(movement){
            case "right":
                sprite_index = mc_jump_right;
                if (theindex != 8)
                {
                    if(theindex &lt; 4)
                    {
                        y -= 5;
                    }else{
                        y += 5;
                    }
                    x +=8.75;
                    theindex++;
                } else {
                    ismoving = 0;
                    theindex = 0;
                    sprite_index = mc_right;
                }
                break;
            case "left":
                sprite_index = mc_jump_left;
                if (theindex != 8)
                {
                    if(theindex &lt; 4)
                    {
                        y -= 5;
                    }else{
                        y += 5;
                    }
                    x -=8.75;
                    theindex++;
                } else {
                    ismoving = 0;
                    theindex = 0;
                    sprite_index = mc_left;
                }
                break;
            case "up":
                sprite_index = mc_jump_up;
                if (theindex != 8)
                {
                    if(theindex &lt; 6)
                    {
                        y -= (70/6);
                    }else{
                        y += 10;
                    }
                    theindex++;
                } else {
                    ismoving = 0;
                    theindex = 0;
                    sprite_index = mc_up;
                }
                break;
            case "down":
                sprite_index = mc_jump_down;
                if (theindex != 8)
                {
                    if(theindex &lt; 6)
                    {
                        y += 5;
                    }else{
                        y += 10;
                    }
                    theindex++;
                } else {
                    ismoving = 0;
                    theindex = 0;
                    sprite_index = mc_down;
                }
                break;
        }
    }
    
    //bullet collision
    //removal of hp is already handled by the bullets, this handles the animation
    if (ishit)
    {    
        //we make the animation go off
        //we make sure to use the movement variable to know where the mc
        //is facing and use the appropriate falling animation
        if(movement = "left" || movement = "down"){
            sprite_index = mc_hurt_left;
        }else{
            sprite_index = mc_hurt_right;
        }
        if (image_index &gt; (image_number-1))
        {
            switch(movement){
                case "left":
                    sprite_index = mc_left;    
                    break;
                case "right":
                    sprite_index = mc_right;
                    break;
                case "up":
                    sprite_index = mc_up;
                    break;
                case "down":
                    sprite_index = mc_down;
                    break;
            }
            ishit = false;
        }
    }
    
    //brain collision
    if (ishit2)
    {
        //we cant be in the middle of motion when we get smacked
        if (!ismoving)
        {
            //we make the animation go off
            //we make sure to use the movement variable to know where the mc
            //is facing and use the appropriate falling animation
            if(movement = "left" || movement = "down"){
                sprite_index = mc_hurt_left;
            }else{
                sprite_index = mc_hurt_right;
            }
            //set the row one down
            cursorRow = 1;
            //and then move the character down
            if (theindex &lt; 8)
            {
                y += (50/8);
                theindex++;
            }
            //and now switch to the standing animation when its over
            if (theindex &gt;= 8)
            {
                switch(movement){
                    case "left":
                        sprite_index = mc_left;    
                        break;
                    case "right":
                        sprite_index = mc_right;
                        break;
                    case "up":
                        sprite_index = mc_up;
                        break;
                    case "down":
                        sprite_index = mc_down;
                        break;
                }
                theindex = 0;
                ishit2 = 0;
            }
        }
    }
    
    //shield cooldown
    if ( s_cooldown &gt; 0){
        s_cooldown--;
    }
    
    //if you lose all your hp
    //currently it takes you to another room
    //which is the gameover room
    if (global.HP == 0)
    {
        battleEndVal = ENDBATTLE_STATUS.DIED;
        battle_setNextState(game_battle, BATTLE_STATE.ENDBATTLE);
        room_goto(rm_dead);
    }
    //first platform at 120,310
    /*ds_queue_enqueue(moveQ, 120 + (cursorCol*70));
    ds_queue_enqueue(moveQ, 310 + (cursorRow*50));*/
    global.moveOK = 0;

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (sprite_index == mc_skill)
{
    switch(movement){
        case "left":
            sprite_index = mc_left;    
            break;
        case "right":
            sprite_index = mc_right;
            break;
        case "up":
            sprite_index = mc_up;
            break;
        case "down":
            sprite_index = mc_down;
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the playerToken in the right spot.

if (global.playerTurnState[PLAYER_TURN_STATE.IMPORT] &amp;&amp; battle_playerTurn.turnRunning
 || global.enmyTurnState[ENEMY_TURN_STATE.ATK] &amp;&amp; battle_enemyTurn.turnRunning) {
    draw_sprite(sprite_index, 0, x, y);
}


if (global.playerTurnState[PLAYER_TURN_STATE.IMPORT] &amp;&amp; battle_playerTurn.turnRunning) {
    if (hitting)
    {
            draw_set_color(c_red);
            draw_text(x-25, y-50, "-"+string(dmg));
            draw_set_color(c_white);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// temporary pewpew button
//if seen fit this code will move to the step event
//this is mostly to NOT crowd said event

if (global.playerTurnState[PLAYER_TURN_STATE.IMPORT] &amp;&amp; battle_playerTurn.turnRunning) {
    q = collision_circle(x, y, 10, obj_glitch, true, true);
    
    if (q){
        inst = instance_place(x,y,obj_glitch);
        if instance_exists(inst){
           if(game_battle.gbt == game_battle.bonus) {
              dmg = atkStr+game_battle.syncBonus;
              inst.HP -= dmg;
              //show_debug_message("Inst # " + string(inst.id) + " HP: " + string(inst.HP));
           }
           else {
              dmg = atkStr;
              inst.HP -= dmg;
           }
            hitting = true;
        }
    }
}

else if (global.enmyTurnState[ENEMY_TURN_STATE.ATK] &amp;&amp; battle_enemyTurn.turnRunning) {
    if (s_cooldown = 0) {
        instance_create(x, y, obj_shield);
        s_cooldown = 50;
        sprite_index = mc_skill;
        
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///making sure to turn off hitting variable
if (global.playerTurnState[PLAYER_TURN_STATE.IMPORT] &amp;&amp; battle_playerTurn.turnRunning) {
    hitting = false;    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.00999999977648258</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
