<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_icon_controller</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init Variables
/*
    Implied variables:
    
    _timeStart       = The time (in ms) that the timer was started
    _sequence       = The sequence currently being used
    _currentTimer   = The timer currently being scanned for (by index)
    _endTimer       = The timer value to call it quits at
 */
 
// The default keys for movement.
MENU_KEY_LEFT_1 = vk_left;
MENU_KEY_LEFT_2 = ord("A");
MENU_KEY_RIGHT_1 = vk_right;
MENU_KEY_RIGHT_2 = ord("D");
MENU_KEY_UP_1 = vk_up;
MENU_KEY_UP_2 = ord("W");
MENU_KEY_DOWN_1 = vk_down;
MENU_KEY_DOWN_2 = ord("S");

show_debug_message("Creating the Rhythm Timer Controller.");
_timeLast = current_time;
__rt_g_timeDeltaAvg = 0;
__rt_g_timeDeltaSample = 0;
__rt_g_timeDeltaTotal = 0;
_paused = false;
ds_queue_clear(__rt_g_rankQueue); // Wipe all old ranks
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Background

// Destroy if the time is up
if (_currentTimer &gt;= _endTimer) {
    show_debug_message("LAST TIMER HIT, DESTROYING FROM RT_CONTROLLER!");
    instance_destroy();
}
    
// Calculate if paused:
if (_paused)
    _timeStart += current_time - _timeLast;
    
// Calculate average delta:
__rt_g_timeDeltaTotal += current_time - _timeLast;
_timeLast = current_time;
++ __rt_g_timeDeltaSample;
if (__rt_g_timeDeltaSample &gt;= TIME.dSamples &amp;&amp; ! _paused)
{  
    __rt_g_timeDeltaAvg = __rt_g_timeDeltaTotal / TIME.dSamples;
    global.timedelta = __rt_g_timeDeltaAvg;
    __rt_g_timeDeltaSample = 0;
    __rt_g_timeDeltaTotal = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check Triggers

// If paused, don't run.
if (_paused)
    exit;

// Grab the correct timer:

/* Var __timer stores the next timer in the sequence. _currentTimer tells us which timer we're on. */
var __timer = _sequence[| _currentTimer];

/* Var __stepTime = the time the trigger was pressed. */
var __stepTime = (current_time - _timeStart);




// Check if the target was missed:
/* If the time that has passed is more than the timer's exact listed time, plus the buffer alotted, plus a delta factor... */
if (__stepTime &gt; __timer[TIMER.time] + __rt_g_missTime + __rt_g_timeDeltaAvg)
{
    ++_currentTimer; //Move to the next timer.
    
    /* DISABLED THE ABILITY TO PASS A MISS IF YOU DON'T HIT ANYTHING AT ALL! */
    /*
    if (__rt_g_functionTrigger != noone)   // If there's a trigger function declared.
        // Execute the function and pass a "miss" in, the sequence, the trigger for that timer and the time for that timer.
        script_execute(__rt_g_functionTrigger, rt_miss, _sequence, 
                       __timer[TIMER.trigger], 
                       __timer[TIMER.time])
    // Then store that "miss" in the ranking queue.
    ds_queue_enqueue(__rt_g_rankQueue, rt_miss);
    */
    exit;
}

// Grab the trigger to check:

/* __trigger is the trigger corresponding to the above timer. */
var __trigger = __timer[TIMER.trigger];

// Check if pressed:

/* If 'check trigger'. The value that comes here is the value of __ret, btw.*/
if (__rt_fhidden_check_trigger(__trigger))
{
    // Check if pressed WAY too early:
    if (__stepTime &lt; __timer[TIMER.time] - __rt_g_missTime - __rt_g_timeDeltaAvg)
    {
        // If the system is set to strict, we mark it as a miss:
        if (rt_system_getstrict())
        {
            ++_currentTimer;
            if (__rt_g_functionTrigger != noone)
                script_execute(__rt_g_functionTrigger, rt_miss, _sequence,
                               __timer[TIMER.trigger], 
                               __timer[TIMER.time]);
            ds_queue_enqueue(__rt_g_rankQueue, rt_miss);
        }
        
        // Otherwise we just ignore it:
        exit;
    }
    
    
    
    // If not too early, we check for the appropriate rank:
    var __match = -1, // No match by default
        __currentms = -1, // Current time for the accepted rank
        // How close did we get to the exact time?
        __triggerDif = abs(__timer[TIMER.time] - __stepTime); // Current marked difference between exact timer time and pressed time
        
    // For every rank in question.    
    for (var i = 0; i &lt; ds_list_size(__rt_g_rankList); ++i)
    {
        var __time = __rt_g_rankList[| i];
        // If we're within the right time of the rank.
        if (__triggerDif &lt; __time)
        {
            // If there's only one rank or a rank previously matched is bigger than this one
            if (__currentms == -1 || __currentms &gt; __time)
            {
                // Set match to be the rank's index and the currentms to the time value of the current rank in question.
                __match = i;
                __currentms = __time;
                continue;
            }
        }
        else
        {
            // If the player missed thanks to lag but would have fallen in time, we give it to them anyway:
            /* If the pressed time - the delta diff (limited to being between 0 and the pressed time) is &lt; the rank time */ 
            if (clamp(__triggerDif - __rt_g_timeDeltaAvg, 0, __triggerDif) &lt; __time)
            {
                // do the same as above.
                if (__currentms == -1 || __currentms &gt; __time)
                {
                    __match = i;
                    __currentms = __time;
                    continue;
                }
            }
        }
    }
    
    // Record the rank scored:
    /* Call the trigger script. and stick the rank on the queue for checking later.*/
    if (__rt_g_functionTrigger != noone)
        script_execute(__rt_g_functionTrigger, __match, _sequence,
                       __timer[TIMER.trigger], 
                       __timer[TIMER.time])
    ds_queue_enqueue(__rt_g_rankQueue, __match);
    ++_currentTimer;
}
else
{
    // We check if OTHER triggers were accidentally pressed!
    for (var i = 0; i &lt; ds_list_size(__rt_g_triggerList); ++i)
    {
        var __trig = __rt_g_triggerList[| i];
        // Check if pressed WAY too early:
        if (__rt_fhidden_check_trigger(__trig[TRIGGER.id]))
        {
            // Check if pressed WAY too early:
            if (__stepTime &lt; __timer[TIMER.time] - __rt_g_missTime - __rt_g_timeDeltaAvg)
            {
                // If the system is set to strict, we mark it as a miss:
                if (rt_system_getstrict())
                {
                    ++_currentTimer;
                    if (__rt_g_functionTrigger != noone)
                        script_execute(__rt_g_functionTrigger, rt_miss, _sequence,
                                       __timer[TIMER.trigger], 
                                       __timer[TIMER.time]);
                    ds_queue_enqueue(__rt_g_rankQueue, rt_miss);
                }
                
                // Otherwise we just ignore it:
                exit;
            }
            
            // If NOT pressed too early, it was the wrong note, so we miss:
            ++_currentTimer;
            if (__rt_g_functionTrigger != noone)
                script_execute(__rt_g_functionTrigger, rt_miss, _sequence,
                               __timer[TIMER.trigger], 
                               __timer[TIMER.time]);
            ds_queue_enqueue(__rt_g_rankQueue, rt_miss);
            exit;
        }
        
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
