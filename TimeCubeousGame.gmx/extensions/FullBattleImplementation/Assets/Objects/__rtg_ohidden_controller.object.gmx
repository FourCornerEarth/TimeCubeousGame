<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_icon_controller</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init

// Hold all timers that are to be drawn:
_drawList = ds_list_create();
// Position of all timers (for optimization later)
_posList = ds_list_create();

// The last timers scanned for drawing:
_lastScannedTimer = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mutable Properties
/*
    These are properties you can modify if you wish. These are
    not intended to be mutable by default, but you can do so
    for more advanced customization.
 */
 
// Movement Properties:
    // The offset angle to start at between [0 .. 90], 0 = no arc, 90 = max arc
    // Used for CCW / CW / Wobbly movement
_arcAngle = 90;
    // The strength of the effect.
    // Wobble: The radius of the wobble distance
    // CCW / CW: The initial offset from the target position
_arcDistance = max(__rtg_g_width, __rtg_g_height) &gt;&gt; 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(_drawList);
ds_list_destroy(_posList);
__rtg_enabled = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw System

// If graphics are not enabled, quit.
if (!__rtg_enabled)
    exit;

// If no sequence is active, quit.
if (!rt_sequence_playing() == noone)
    exit;
if (!instance_exists(__rt_ohidden_controller))
    exit;
    
// We use the passthrough to negate any 3D lighting or other shaders in use:
if (__rtg_g_useShaders)
    shader_set(rt_passthrough_shd);
    
// Re-create the surface if it was destroyed:
if (!surface_exists(__rtg_g_surface))
    __rtg_g_surface = surface_create(__rtg_g_width, __rtg_g_height);
    
// Scan for timers to draw:
var __seq = __rt_ohidden_controller._sequence; // The playing sequence
var __deltaTime = current_time - __rt_ohidden_controller._timeStart; // Current time in sequence

for (var i = _lastScannedTimer + 1; i &lt; ds_list_size(__seq); ++i)
{
    var __timer = __seq[| i];
    
    // Skip ones that aren't drawn:
    if (!__timer[TIMER.usingGraphics])
    {
        ++_lastScannedTimer;
        continue;
    }
    
    // If no graphic assigned to the associated trigger, skip:
    var __trigger = __rt_fhidden_find_trigger(__timer[TIMER.trigger]);
    if (!__trigger[TRIGGER.usingGraphics])
    {
        ++_lastScannedTimer;
        continue;
    }
    
    // Check if we are within range of drawing:
    var __draw = false;
    var __dif = __timer[TIMER.time] - __deltaTime;
    
        // Fits in the time-slot before the trigger
    if (__dif &gt;= 0 &amp;&amp; __dif &lt;= __rtg_g_visualTime)
        __draw = true;
        
        // Draw until it is considered a "miss":
    if (__dif &lt; 0 &amp;&amp; -__dif &lt;= __rt_g_missTime)
        __draw = true;
        
    // If out of range, we end early to avoid unnecessary analysis
    if (!__draw)
        break;
        
    ds_list_add(_drawList, __timer);
    ++_lastScannedTimer;
}

// Scan through old timers to see if we need to remove them:
var __ctimer = __seq[| __rt_ohidden_controller._currentTimer];
// Must have the check is_array() in case we access an out-of-bounds location (at the end of the sequence)
while (! ds_list_empty(_drawList) &amp;&amp; is_array(__ctimer))
{
    var __timer = _drawList[| 0];
    
    // Delete if the current timer has passed this one.
    // This also will handle deleting the timer when it is triggered early
    if (__timer[TIMER.time] &lt; __ctimer[TIMER.time])
    {
        ds_list_delete(_drawList, 0);
        continue;
    } 
    else
        break;
}
    
// Draw the graphics to the main surface:
surface_set_target(__rtg_g_surface);
draw_clear_alpha(0, 0);

ds_list_clear(_posList); // Clear all the prior positions

// Draw the base buttons:
for (var i = 0; i &lt; ds_list_size(_drawList); ++i)
{
    var __timer = _drawList[| i];
    var __trigger = __rt_fhidden_find_trigger(__timer[TIMER.trigger]);
                  
    // Static
    draw_sprite_ext(__trigger[TRIGGER_G.sprite], image_index, 
                    __timer[TIMER_G.xpos], __timer[TIMER_G.ypos],
                    1, 1, 0, c_white, 1);
                    
}

// Draw the dynamic images on top:
for (var i = 0; i &lt; ds_list_size(_drawList); ++i)
{
    var __timer = _drawList[| i];
    var __trigger = __rt_fhidden_find_trigger(__timer[TIMER.trigger]);
    
    var __iconSize = max(sprite_get_width(__trigger[TRIGGER_G.sprite]), 
                         sprite_get_height(__trigger[TRIGGER_G.sprite]));

        // Scalar ranges from [0..1] for point on path to draw target
    var __scalar = 1 / __rtg_g_visualTime * (__timer[TIMER.time] - __deltaTime);
    // Moving:
        // Calculate the start positions for the icon:
        
    var __xstart, __ystart;
        // Size of the drawspace:
    var __w = (__rtg_g_width &gt;&gt; 1) + __iconSize,
        __h = (__rtg_g_height &gt;&gt; 1) + __iconSize,
        __dir = __timer[TIMER_G.entryDirection];
 
    // Find position on the edge of the boarder:
    var __anear = round(__dir / 90) * 90;
    var __nx = dcos(__anear),
        __ny = dsin(__anear);
    __xstart = (__rtg_g_width / 2) + __nx * __w;
    __ystart = (__rtg_g_height / 2) + __ny * __w;
    if (__nx == 0)
        __xstart += __w / 45 * angle_difference(__anear, __dir) * sign(__ny);
    if (__ny == 0)
        __ystart += __h / 45 * angle_difference(__anear, __dir) * sign(__nx);
    

        // The position to actually draw the button:
    var __dx, __dy;
    
    // Calculate the actual movement:
    switch (__timer[TIMER_G.movementStyle])
    {
        // CW Curve:
        case rtg_curvedcw:
            var __angle = _arcAngle / __rtg_g_visualTime *
                         (__timer[TIMER.time] - __deltaTime);
            var __tx = __timer[TIMER_G.xpos], 
                __ty = __timer[TIMER_G.ypos];
            var __dir = point_direction(__xstart, __ystart, __tx, __ty);
                
            __tx += dcos(__dir + 90) * (_arcDistance) * dsin(__angle);
            __ty -= dsin(__dir + 90) * (_arcDistance) * dsin(__angle);
            
            __dx =__xstart + (__tx - __xstart)/ __rtg_g_visualTime *
                             (__rtg_g_visualTime - (__timer[TIMER.time] - __deltaTime));
            __dy =__ystart + (__ty - __ystart) / __rtg_g_visualTime *
                             (__rtg_g_visualTime - (__timer[TIMER.time] - __deltaTime));
            
        break;
        
        // CCW Curve:
        case rtg_curvedccw:
            var __angle = _arcAngle / __rtg_g_visualTime *
                         (__timer[TIMER.time] - __deltaTime);
            var __tx = __timer[TIMER_G.xpos], 
                __ty = __timer[TIMER_G.ypos];
            var __dir = point_direction(__xstart, __ystart, __tx, __ty);
                
            __tx += dcos(__dir - 90) * (_arcDistance) * dsin(__angle);
            __ty -= dsin(__dir - 90) * (_arcDistance) * dsin(__angle);
            
            __dx =__xstart + (__tx - __xstart)/ __rtg_g_visualTime *
                             (__rtg_g_visualTime - (__timer[TIMER.time] - __deltaTime));
            __dy =__ystart + (__ty - __ystart) / __rtg_g_visualTime *
                             (__rtg_g_visualTime - (__timer[TIMER.time] - __deltaTime));
            
        break;
        
        // Wobbly:
        case rtg_wobbly:
            var __angle = 90 / __rtg_g_visualTime *
                         (__timer[TIMER.time] - __deltaTime);
            var __tx = __timer[TIMER_G.xpos], 
                __ty = __timer[TIMER_G.ypos];
            var __dir = point_direction(__xstart, __ystart, __tx, __ty);
            
            var __ang = dcos(direction) * _arcDistance;
            __tx += __ang * dcos(__dir + 90) * dsin(__angle);
            __ty -= __ang * dsin(__dir + 90) * dsin(__angle);
            
            __dx =__xstart + (__tx - __xstart)/ __rtg_g_visualTime *
                             (__rtg_g_visualTime - (__timer[TIMER.time] - __deltaTime));
            __dy =__ystart + (__ty - __ystart) / __rtg_g_visualTime *
                             (__rtg_g_visualTime - (__timer[TIMER.time] - __deltaTime));
            
            
            
        break;

        // Linear:
        default: 
            var __tx = __timer[TIMER_G.xpos], 
                __ty = __timer[TIMER_G.ypos];
            __dx =__xstart + (__tx - __xstart)/ __rtg_g_visualTime *
                             (__rtg_g_visualTime - (__timer[TIMER.time] - __deltaTime));
            __dy =__ystart + (__ty - __ystart) / __rtg_g_visualTime *
                             (__rtg_g_visualTime - (__timer[TIMER.time] - __deltaTime));
        break;
    }
    
    // Finally, draw the moving button:
    if (__rtg_g_useShaders &amp;&amp; __trigger[TRIGGER_G.grayscale])
        shader_set(rt_grayscale_shd);
    draw_sprite_ext(__trigger[TRIGGER_G.sprite2], image_index, 
                    __dx, __dy, 1, 1, 0, c_white, 1);
    
    if (__rtg_g_useShaders &amp;&amp; __trigger[TRIGGER_G.grayscale])
    {
        shader_reset();
        shader_set(rt_passthrough_shd);
    }
    
    ds_list_add(_posList, __dx, __dy); // Store positions so other functions can call them
    // Draw arrow:
    if (__rtg_g_visualArrow &gt;= 0)
    {
        // Rotating:
        draw_sprite_ext(__rtg_g_visualArrow, image_index,
                        __timer[TIMER_G.xpos], __timer[TIMER_G.ypos],
                        1, 1, __rtg_g_visualAngle / __rtg_g_visualTime * (__timer[TIMER.time] - __deltaTime),
                        c_white, 1);
    }
}

surface_reset_target();

// Used for the "wobbly" effect:
// NOTE: This does NOT take into account lag!
// Replace room_speed with fps to do so, however
// you get extremely low values at game start.
if (!__rt_ohidden_controller._paused)
    direction += 10 / room_speed * 30;
    
if (__rtg_g_useShaders)
    shader_reset();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Surface
if (!surface_exists(__rtg_g_surface))
    __rtg_g_surface = surface_create(__rtg_g_width, __rtg_g_height);

if (__rtg_g_useShaders)
    shader_set(rt_passthrough_shd);
    
draw_surface_ext(__rtg_g_surface, 0, 0, __rtg_g_surfaceScale, __rtg_g_surfaceScale, 0, c_white, 1);

if (__rtg_g_useShaders)
    shader_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
