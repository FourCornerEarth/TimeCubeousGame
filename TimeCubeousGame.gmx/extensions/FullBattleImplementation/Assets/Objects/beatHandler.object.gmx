<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_icon_effect</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Start the song off!

creCt = 0;
created = 0;
global.isMiss = 0;
i = 0;
alarmSet = 0;
enemyAlarmSet = 0;
justSwitched = 0;

playercol = 4;
playerrow = 4;

global.timedelta = 0;
beat = 0;
    draw_set_color(c_white);
    draw_set_font(fnt_bubbleButts);

show_debug_message("Creating beat handler.");

rt_system_settriggerfunction("checkForBeatOn");

global.move = ds_queue_create();
global.moveRtLt = ds_queue_create();

// Don't set strict so that drastically missing notes are "misses".
rt_system_setstrict(1);


// Make ranks. If you hit the target within 85 ms before and after, you're good.
show_debug_message("Made ranks.");
global.hit = rt_rank_create(80);
//global.m = rt_rank_create(690);


// Create the sequence for the song.
show_debug_message("Creating sequence.");
seq = rt_sequence_create();

// Turn the bpm to the song into ms.
var ms = rt_bpmtoms(172);


// Make the triggers to test for user input.
show_debug_message("Setting trigger and adding timers.");
move = rt_trigger_create("checkTriggerHit");


for (var i = 105; i &lt;= ms*1000; i+= ms) {
    rt_timer_add(seq, move, i);
}

// Set various variables to work with.
global.moveOK = 0; // increment every time moving is okay.
count = 0;
lastRank = -1;
seqOver = 0;
nowTime = 0;
startTime = current_time;


show_debug_message("Starting music.");
//rt_sequence_start(seq);
audio_play_sound(battleSong172BPM, 1, true);

// Assign stateID corresponding to btlState's playerTurn state.
objStateID = PLAYER_TURN_STATE.IMPORT;

state_addSelfToRegistry(global.playerTurnState, global.playerTurnReg, objStateID);
state_addSelfToRegistry(global.enmyTurnState, global.enmyTurnReg, objStateID);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Release an enemy

         //created = 1;
         var vrbl = choose(UNDO, UNDO_hard);
         p = irandom(100);
         if (p &gt; 25) {
            i = irandom(8);
            instance_create(120+(i*70), 110, vrbl);
            //creCt = 30;
         }
         created = 0;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// End the battle turn.
    battle_enemyTurn.turnRunning = 0;
    //rt_system_setpaused(rt_system_getpaused());
    battle_setNextState(battle_enemyTurn, ENEMY_TURN_STATE.TURN_OVER);
    justSwitched = 1;
    // unpause
                                                                        

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// End the player turn.
        
    //end the player turn
    battle_playerTurn.turnRunning = 0;
    battle_setNextState(battle_playerTurn, PLAYER_TURN_STATE.TURN_OVER);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for state and start up the import.

// if offensive run
if (!global.enmyTurnState[ENEMY_TURN_STATE.ATK]) {
  if (justSwitched) {
   justSwitched = 0;
   background_visible[0] = true;
   background_visible[1] = false;
    
    
    //core location and scaling
    obj_Core.x = 400;
    obj_Core.y = 300;
    obj_Core.image_xscale = 1;
    obj_Core.image_yscale = 1;
    //changes core color back to normal just in case
    obj_Core.image_blend = -1;
    
    //moves player token, changes sprite
    rikuToken.x = 217 + (playercol*38);
    rikuToken.y = 125 + (playerrow*38);
    rikuToken.cursorRow = playerrow;
    rikuToken.cursorCol = playercol;
    
    rikuToken.sprite_index = spr_crosshair;
    
    //makes glitches visible
    if object_exists(obj_glitch)
    {
        with (obj_glitch) {obj_glitch.visible = true;}
    }
    
    //destroys any UNDO orbs left
    
    if object_exists(UNDO){
        with (UNDO) {instance_destroy();}
    }
    
    //colliusion with core is of
    rikuToken.brcol_on = 0;
  }
   
  if (global.playerTurnState[PLAYER_TURN_STATE.IMPORT] &amp;&amp; !battle_playerTurn.turnRunning) {
   battle_playerTurn.turnRunning = 1;
   //rt_sequence_start(seq);
   //rt_system_setpaused(1);
     if(!alarmSet) {   
       alarm[0] = room_speed*5;
     }
   }// if player turn state

  else if (!global.playerTurnState[PLAYER_TURN_STATE.IMPORT]) {
    alarmSet = 0;
  }
} //end if !enemyTurnState

//if defensive run
else if (global.btlState[BATTLE_STATE.ENEMY_TURN]) {
 if (global.enmyTurnState[ENEMY_TURN_STATE.ATK] &amp;&amp; !battle_enemyTurn.turnRunning) {
   battle_enemyTurn.turnRunning = 1;
   show_debug_message("Should be able to switch backgrounds here.");
   if (justSwitched) {
     justSwitched = 0;
   //changes background to defense bg
    background_visible[0] = false;
    background_visible[1] = true;
    
    
    //core location and scaling
    obj_Core.x = 400;
    obj_Core.y = 192;
    obj_Core.image_xscale = .4;
    obj_Core.image_yscale = .4;
    
    
    //saves the current col and row then
    playercol = rikuToken.cursorCol;
    playerrow = rikuToken.cursorRow;
    
    //moves player token, changes sprite
    rikuToken.cursorRow = 2;
    rikuToken.cursorCol = 4;
    rikuToken.x = 120 + (rikuToken.cursorCol*70);
    rikuToken.y = 310 + (rikuToken.cursorRow*50);
    
    rikuToken.sprite_index = mc_up;
    
    //makes glitches invisible
    if object_exists(obj_glitch)
    {
        with (obj_glitch) {obj_glitch.visible = false;}
    }
    //sets alarm for the collision to turn on
    rikuToken.alarm[0] = room_speed*.5;
    //}

   //rt_system_setpaused(0);
   
   
   if(!enemyAlarmSet) {
      alarm[1] = room_speed*9;
   }
 }//justSwitched

 
} 
 else if (!global.enmyTurnState[ENEMY_TURN_STATE.ATK]) {
    enemyAlarmSet = 0;
 }

}

// Spawns enemies.
if (global.enmyTurnState[ENEMY_TURN_STATE.ATK] &amp;&amp; !created) {
   created = 1;
   alarm[2] = irandom_range(room_speed*.25, room_speed*.55);  

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw if we're on beat to tell the player when to hit!

/*if (!seqOver) {
draw_text(20, 20, "Beat: " + string(beat));
}*/

// If we're on beat, leave a message for the player.
/*if (global.onBeat) { 
    draw_text(350, 30, "ON BEAT!");
    global.onBeat = 0;
}*/



/*if(rt_sequence_isplaying(seq)) {
  if (checkInBeatTime(120)) {
     draw_text(350, 30, "ON BEAT!");
  }
}*/

/*if (global.isMiss) {
   i++;
   draw_set_color(c_red);
   draw_text(275, 75+(3*i), "COMBO BROKEN!");
   draw_set_color(c_white);
   global.isMiss--;
}

else i = 0;
//if (seqOver) { 
//   draw_text(350, 30, "SONG OVER!");
//}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
